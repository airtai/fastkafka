"use strict";(self.webpackChunkfastkafka=self.webpackChunkfastkafka||[]).push([[2368],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>N});var n=a(7294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function d(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var p=n.createContext({}),o=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):d(d({},e),t)),a},m=function(t){var e=o(t.components);return n.createElement(p.Provider,{value:e},t.children)},k="mdxType",s={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},u=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,p=t.parentName,m=i(t,["components","mdxType","originalType","parentName"]),k=o(a),u=l,N=k["".concat(p,".").concat(u)]||k[u]||s[u]||r;return a?n.createElement(N,d(d({ref:e},m),{},{components:a})):n.createElement(N,d({ref:e},m))}));function N(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,d=new Array(r);d[0]=u;var i={};for(var p in e)hasOwnProperty.call(e,p)&&(i[p]=e[p]);i.originalType=t,i[k]="string"==typeof t?t:l,d[1]=i;for(var o=2;o<r;o++)d[o]=a[o];return n.createElement.apply(null,d)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},567:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>d,default:()=>s,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var n=a(7462),l=(a(7294),a(3905));const r={},d=void 0,i={unversionedId:"api/fastkafka/encoder/AvroBase",id:"version-0.8.0/api/fastkafka/encoder/AvroBase",title:"AvroBase",description:"fastkafka.encoder.AvroBase {fastkafka.encoder.AvroBase}",source:"@site/versioned_docs/version-0.8.0/api/fastkafka/encoder/AvroBase.md",sourceDirName:"api/fastkafka/encoder",slug:"/api/fastkafka/encoder/AvroBase",permalink:"/docs/api/fastkafka/encoder/AvroBase",draft:!1,tags:[],version:"0.8.0",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"KafkaEvent",permalink:"/docs/api/fastkafka/KafkaEvent"},next:{title:"avro_decoder",permalink:"/docs/api/fastkafka/encoder/avro_decoder"}},p={},o=[{value:"fastkafka.encoder.AvroBase",id:"fastkafka.encoder.AvroBase",level:2},{value:"<strong>init</strong>",id:"pydantic.main.BaseModel.init",level:3},{value:"avro_schema",id:"fastkafka._components.encoder.avro.AvroBase.avro_schema",level:3},{value:"avro_schema_for_pydantic_class",id:"fastkafka._components.encoder.avro.AvroBase.avro_schema_for_pydantic_class",level:3},{value:"avro_schema_for_pydantic_object",id:"fastkafka._components.encoder.avro.AvroBase.avro_schema_for_pydantic_object",level:3},{value:"copy",id:"pydantic.main.BaseModel.copy",level:3},{value:"model_computed_fields",id:"pydantic.main.BaseModel.model_computed_fields",level:3},{value:"model_construct",id:"pydantic.main.BaseModel.model_construct",level:3},{value:"model_copy",id:"pydantic.main.BaseModel.model_copy",level:3},{value:"model_dump",id:"pydantic.main.BaseModel.model_dump",level:3},{value:"model_dump_json",id:"pydantic.main.BaseModel.model_dump_json",level:3},{value:"model_extra",id:"pydantic.main.BaseModel.model_extra",level:3},{value:"model_fields_set",id:"pydantic.main.BaseModel.model_fields_set",level:3},{value:"model_json_schema",id:"pydantic.main.BaseModel.model_json_schema",level:3},{value:"model_parametrized_name",id:"pydantic.main.BaseModel.model_parametrized_name",level:3},{value:"model_post_init",id:"pydantic.main.BaseModel.model_post_init",level:3},{value:"model_rebuild",id:"pydantic.main.BaseModel.model_rebuild",level:3},{value:"model_validate",id:"pydantic.main.BaseModel.model_validate",level:3},{value:"model_validate_json",id:"pydantic.main.BaseModel.model_validate_json",level:3}],m={toc:o},k="wrapper";function s(t){let{components:e,...a}=t;return(0,l.kt)(k,(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"fastkafka.encoder.AvroBase"},"fastkafka.encoder.AvroBase"),(0,l.kt)("a",{href:"https://github.com/airtai/fastkafka/blob/0.8.0/fastkafka/_components/encoder/avro.py#L22-L235",class:"link-to-source",target:"_blank"},"View source"),(0,l.kt)("p",null,"This is base pydantic class that will add some methods"),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.init"},(0,l.kt)("strong",{parentName:"h3"},"init")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"__init__(\n    __pydantic_self__, data\n)\n")),(0,l.kt)("p",null,"Create a new model by parsing and validating input data from keyword arguments."),(0,l.kt)("p",null,"Raises ValidationError if the input data cannot be parsed to form a valid model."),(0,l.kt)("p",null,"Uses ",(0,l.kt)("inlineCode",{parentName:"p"},"__pydantic_self__")," instead of the more common ",(0,l.kt)("inlineCode",{parentName:"p"},"self")," for the first arg to\nallow ",(0,l.kt)("inlineCode",{parentName:"p"},"self")," as a field name."),(0,l.kt)("h3",{id:"fastkafka._components.encoder.avro.AvroBase.avro_schema"},"avro_schema"),(0,l.kt)("a",{href:"https://github.com/airtai/fastkafka/blob/0.8.0/fastkafka/_components/encoder/avro.py#L80-L99",class:"link-to-source",target:"_blank"},"View source"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\navro_schema(\n    by_alias=True, namespace=None\n)\n")),(0,l.kt)("p",null,"Returns the Avro schema for the Pydantic class."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"by_alias")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bool")),(0,l.kt)("td",{parentName:"tr",align:null},"Generate schemas using aliases defined. Defaults to True."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"namespace")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Optional[str]")),(0,l.kt)("td",{parentName:"tr",align:null},"Optional namespace string for schema generation."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Dict[str, Any]")),(0,l.kt)("td",{parentName:"tr",align:null},"The Avro schema for the model.")))),(0,l.kt)("h3",{id:"fastkafka._components.encoder.avro.AvroBase.avro_schema_for_pydantic_class"},"avro_schema_for_pydantic_class"),(0,l.kt)("a",{href:"https://github.com/airtai/fastkafka/blob/0.8.0/fastkafka/_components/encoder/avro.py#L53-L77",class:"link-to-source",target:"_blank"},"View source"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\navro_schema_for_pydantic_class(\n    pydantic_model, by_alias=True, namespace=None\n)\n")),(0,l.kt)("p",null,"Returns the Avro schema for the given Pydantic class."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"pydantic_model")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Type[pydantic.main.BaseModel]")),(0,l.kt)("td",{parentName:"tr",align:null},"The Pydantic class."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"required"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"by_alias")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bool")),(0,l.kt)("td",{parentName:"tr",align:null},"Generate schemas using aliases defined. Defaults to True."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"namespace")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Optional[str]")),(0,l.kt)("td",{parentName:"tr",align:null},"Optional namespace string for schema generation."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Dict[str, Any]")),(0,l.kt)("td",{parentName:"tr",align:null},"The Avro schema for the model.")))),(0,l.kt)("h3",{id:"fastkafka._components.encoder.avro.AvroBase.avro_schema_for_pydantic_object"},"avro_schema_for_pydantic_object"),(0,l.kt)("a",{href:"https://github.com/airtai/fastkafka/blob/0.8.0/fastkafka/_components/encoder/avro.py#L26-L50",class:"link-to-source",target:"_blank"},"View source"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\navro_schema_for_pydantic_object(\n    pydantic_model, by_alias=True, namespace=None\n)\n")),(0,l.kt)("p",null,"Returns the Avro schema for the given Pydantic object."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"pydantic_model")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"BaseModel")),(0,l.kt)("td",{parentName:"tr",align:null},"The Pydantic object."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"required"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"by_alias")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bool")),(0,l.kt)("td",{parentName:"tr",align:null},"Generate schemas using aliases defined. Defaults to True."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"namespace")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Optional[str]")),(0,l.kt)("td",{parentName:"tr",align:null},"Optional namespace string for schema generation."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Dict[str, Any]")),(0,l.kt)("td",{parentName:"tr",align:null},"The Avro schema for the model.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.copy"},"copy"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"copy(\n    self, include=None, exclude=None, update=None, deep=False\n)\n")),(0,l.kt)("p",null,"Returns a copy of the model."),(0,l.kt)("p",null,"This method is now deprecated; use ",(0,l.kt)("inlineCode",{parentName:"p"},"model_copy")," instead. If you need ",(0,l.kt)("inlineCode",{parentName:"p"},"include")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"exclude"),", use:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"include")),(0,l.kt)("td",{parentName:"tr",align:null},"AbstractSetIntStr"),(0,l.kt)("td",{parentName:"tr",align:null},"MappingIntStrAny"),(0,l.kt)("td",{parentName:"tr",align:null},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude")),(0,l.kt)("td",{parentName:"tr",align:null},"AbstractSetIntStr"),(0,l.kt)("td",{parentName:"tr",align:null},"MappingIntStrAny"),(0,l.kt)("td",{parentName:"tr",align:null},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"update")),(0,l.kt)("td",{parentName:"tr",align:null},"`Dict","[str, Any]"),(0,l.kt)("td",{parentName:"tr",align:null},"None`"),(0,l.kt)("td",{parentName:"tr",align:null},"Optional dictionary of field-value pairs to override field valuesin the copied model.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"deep")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"If True, the values of fields that are Pydantic models will be deep copied."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Model")),(0,l.kt)("td",{parentName:"tr",align:null},"A copy of the model with included, excluded and updated fields as specified.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_computed_fields"},"model_computed_fields"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@property\nmodel_computed_fields(\n    self\n)\n")),(0,l.kt)("p",null,"Get the computed fields of this model instance."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"dict[str, ComputedFieldInfo]")),(0,l.kt)("td",{parentName:"tr",align:null},"A dictionary of computed field names and their corresponding ",(0,l.kt)("inlineCode",{parentName:"td"},"ComputedFieldInfo")," objects.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_construct"},"model_construct"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\nmodel_construct(\n    _fields_set=None, values\n)\n")),(0,l.kt)("p",null,"Creates a new instance of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Model")," class with validated data."),(0,l.kt)("p",null,"Creates a new model setting ",(0,l.kt)("inlineCode",{parentName:"p"},"__dict__")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"__pydantic_fields_set__")," from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nBehaves as if ",(0,l.kt)("inlineCode",{parentName:"p"},"Config.extra = 'allow'")," was set since it adds all passed values"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"_fields_set")),(0,l.kt)("td",{parentName:"tr",align:null},"set","[str]"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"The set of field names accepted for the Model instance.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"values")),(0,l.kt)("td",{parentName:"tr",align:null},"Any"),(0,l.kt)("td",{parentName:"tr",align:null},"Trusted or pre-validated data dictionary."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"required"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Model")),(0,l.kt)("td",{parentName:"tr",align:null},"A new instance of the ",(0,l.kt)("inlineCode",{parentName:"td"},"Model")," class with validated data.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_copy"},"model_copy"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"model_copy(\n    self, update=None, deep=False\n)\n")),(0,l.kt)("p",null,"Returns a copy of the model."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"update")),(0,l.kt)("td",{parentName:"tr",align:null},"dict","[str, Any]"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Values to change/add in the new model. Note: the data is not validatedbefore creating the new model. You should trust this data.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"deep")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Set to ",(0,l.kt)("inlineCode",{parentName:"td"},"True")," to make a deep copy of the model."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Model")),(0,l.kt)("td",{parentName:"tr",align:null},"New model instance.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_dump"},"model_dump"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"model_dump(\n    self,\n    mode='python',\n    include=None,\n    exclude=None,\n    by_alias=False,\n    exclude_unset=False,\n    exclude_defaults=False,\n    exclude_none=False,\n    round_trip=False,\n    warnings=True,\n)\n")),(0,l.kt)("p",null,"Usage docs: ",(0,l.kt)("a",{parentName:"p",href:"https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump"},"https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump")),(0,l.kt)("p",null,"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"mode")),(0,l.kt)("td",{parentName:"tr",align:null},"Literal","['json', 'python']"),(0,l.kt)("td",{parentName:"tr",align:null},"str"),(0,l.kt)("td",{parentName:"tr",align:null},"The mode in which ",(0,l.kt)("inlineCode",{parentName:"td"},"to_python")," should run.If mode is 'json', the dictionary will only contain JSON serializable types.If mode is 'python', the dictionary may contain any Python objects.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"include")),(0,l.kt)("td",{parentName:"tr",align:null},"IncEx"),(0,l.kt)("td",{parentName:"tr",align:null},"A list of fields to include in the output."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude")),(0,l.kt)("td",{parentName:"tr",align:null},"IncEx"),(0,l.kt)("td",{parentName:"tr",align:null},"A list of fields to exclude from the output."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"by_alias")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to use the field's alias in the dictionary key if defined."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude_unset")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to exclude fields that are unset or None from the output."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude_defaults")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to exclude fields that are set to their default value from the output."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude_none")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to exclude fields that have a value of ",(0,l.kt)("inlineCode",{parentName:"td"},"None")," from the output."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"round_trip")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to enable serialization and deserialization round-trip support."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"warnings")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to log warnings when invalid fields are encountered."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"dict[str, Any]")),(0,l.kt)("td",{parentName:"tr",align:null},"A dictionary representation of the model.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_dump_json"},"model_dump_json"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"model_dump_json(\n    self,\n    indent=None,\n    include=None,\n    exclude=None,\n    by_alias=False,\n    exclude_unset=False,\n    exclude_defaults=False,\n    exclude_none=False,\n    round_trip=False,\n    warnings=True,\n)\n")),(0,l.kt)("p",null,"Usage docs: ",(0,l.kt)("a",{parentName:"p",href:"https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump_json"},"https://docs.pydantic.dev/dev-v2/usage/serialization/#modelmodel_dump_json")),(0,l.kt)("p",null,"Generates a JSON representation of the model using Pydantic's ",(0,l.kt)("inlineCode",{parentName:"p"},"to_json")," method."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"indent")),(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Indentation to use in the JSON output. If None is passed, the output will be compact.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"include")),(0,l.kt)("td",{parentName:"tr",align:null},"IncEx"),(0,l.kt)("td",{parentName:"tr",align:null},"Field(s) to include in the JSON output. Can take either a string or set of strings."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude")),(0,l.kt)("td",{parentName:"tr",align:null},"IncEx"),(0,l.kt)("td",{parentName:"tr",align:null},"Field(s) to exclude from the JSON output. Can take either a string or set of strings."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"None"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"by_alias")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to serialize using field aliases."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude_unset")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to exclude fields that have not been explicitly set."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude_defaults")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to exclude fields that have the default value."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"exclude_none")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to exclude fields that have a value of ",(0,l.kt)("inlineCode",{parentName:"td"},"None"),"."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"round_trip")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to use serialization/deserialization between JSON and class instance."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"warnings")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to show any warnings that occurred during serialization."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"str")),(0,l.kt)("td",{parentName:"tr",align:null},"A JSON string representation of the model.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_extra"},"model_extra"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@property\nmodel_extra(\n    self\n)\n")),(0,l.kt)("p",null,"Get extra fields set during validation."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"`dict","[str, Any]"),(0,l.kt)("td",{parentName:"tr",align:null},"None`")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_fields_set"},"model_fields_set"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@property\nmodel_fields_set(\n    self\n)\n")),(0,l.kt)("p",null,"Returns the set of fields that have been set on this model instance."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"set[str]")),(0,l.kt)("td",{parentName:"tr",align:null},"A set of strings representing the fields that have been set,i.e. that were not filled from defaults.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_json_schema"},"model_json_schema"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\nmodel_json_schema(\n    by_alias=True,\n    ref_template='#/$defs/{model}',\n    schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>,\n    mode='validation',\n)\n")),(0,l.kt)("p",null,"Generates a JSON schema for a model class."),(0,l.kt)("p",null,"To override the logic used to generate the JSON schema, you can create a subclass of ",(0,l.kt)("inlineCode",{parentName:"p"},"GenerateJsonSchema"),"\nwith your desired modifications, then override this method on a custom base class and set the default\nvalue of ",(0,l.kt)("inlineCode",{parentName:"p"},"schema_generator")," to be your subclass."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"by_alias")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to use attribute aliases or not."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ref_template")),(0,l.kt)("td",{parentName:"tr",align:null},"str"),(0,l.kt)("td",{parentName:"tr",align:null},"The reference template."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"'#/$defs/{model}'"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"schema_generator")),(0,l.kt)("td",{parentName:"tr",align:null},"type","[GenerateJsonSchema]"),(0,l.kt)("td",{parentName:"tr",align:null},"The JSON schema generator."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"<class 'pydantic.json_schema.GenerateJsonSchema'>"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"mode")),(0,l.kt)("td",{parentName:"tr",align:null},"JsonSchemaMode"),(0,l.kt)("td",{parentName:"tr",align:null},"The mode in which to generate the schema."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"'validation'"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"dict[str, Any]")),(0,l.kt)("td",{parentName:"tr",align:null},"The JSON schema for the given model class.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_parametrized_name"},"model_parametrized_name"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\nmodel_parametrized_name(\n    params\n)\n")),(0,l.kt)("p",null,"Compute the class name for parametrizations of generic classes."),(0,l.kt)("p",null,"This method can be overridden to achieve a custom naming scheme for generic BaseModels."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"params")),(0,l.kt)("td",{parentName:"tr",align:null},"tuple[type","[Any]",", ...]"),(0,l.kt)("td",{parentName:"tr",align:null},"Tuple of types of the class. Given a generic class",(0,l.kt)("inlineCode",{parentName:"td"},"Model")," with 2 type variables and a concrete model ",(0,l.kt)("inlineCode",{parentName:"td"},"Model[str, int]"),",the value ",(0,l.kt)("inlineCode",{parentName:"td"},"(str, int)")," would be passed to ",(0,l.kt)("inlineCode",{parentName:"td"},"params"),"."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"required"))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"str")),(0,l.kt)("td",{parentName:"tr",align:null},"String representing the new class where ",(0,l.kt)("inlineCode",{parentName:"td"},"params")," are passed to ",(0,l.kt)("inlineCode",{parentName:"td"},"cls")," as type variables.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exceptions"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"TypeError")),(0,l.kt)("td",{parentName:"tr",align:null},"Raised when trying to generate concrete names for non-generic models.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_post_init"},"model_post_init"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"model_post_init(\n    self, _BaseModel__context\n)\n")),(0,l.kt)("p",null,"Override this method to perform additional initialization after ",(0,l.kt)("inlineCode",{parentName:"p"},"__init__")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"model_construct"),"."),(0,l.kt)("p",null,"This is useful if you want to do some validation that requires the entire model to be initialized."),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_rebuild"},"model_rebuild"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\nmodel_rebuild(\n    force=False,\n    raise_errors=True,\n    _parent_namespace_depth=2,\n    _types_namespace=None,\n)\n")),(0,l.kt)("p",null,"Try to rebuild the pydantic-core schema for the model."),(0,l.kt)("p",null,"This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"force")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to force the rebuilding of the model schema, defaults to ",(0,l.kt)("inlineCode",{parentName:"td"},"False"),"."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"raise_errors")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to raise errors, defaults to ",(0,l.kt)("inlineCode",{parentName:"td"},"True"),"."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"True"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"_parent_namespace_depth")),(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"The depth level of the parent namespace, defaults to 2."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"_types_namespace")),(0,l.kt)("td",{parentName:"tr",align:null},"dict","[str, Any]"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"The types namespace, defaults to ",(0,l.kt)("inlineCode",{parentName:"td"},"None"),".")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"`bool"),(0,l.kt)("td",{parentName:"tr",align:null},"None`")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_validate"},"model_validate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\nmodel_validate(\n    obj, strict=None, from_attributes=None, context=None\n)\n")),(0,l.kt)("p",null,"Validate a pydantic model instance."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"obj")),(0,l.kt)("td",{parentName:"tr",align:null},"Any"),(0,l.kt)("td",{parentName:"tr",align:null},"The object to validate."),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"required"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"strict")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to raise an exception on invalid fields.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"from_attributes")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to extract data from object attributes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"context")),(0,l.kt)("td",{parentName:"tr",align:null},"dict","[str, Any]"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Additional context to pass to the validator.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Model")),(0,l.kt)("td",{parentName:"tr",align:null},"The validated model instance.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exceptions"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ValidationError")),(0,l.kt)("td",{parentName:"tr",align:null},"If the object could not be validated.")))),(0,l.kt)("h3",{id:"pydantic.main.BaseModel.model_validate_json"},"model_validate_json"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"@classmethod\nmodel_validate_json(\n    json_data, strict=None, context=None\n)\n")),(0,l.kt)("p",null,"Validate the given JSON data against the Pydantic model."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"json_data")),(0,l.kt)("td",{parentName:"tr",align:null},"str"),(0,l.kt)("td",{parentName:"tr",align:null},"bytes"),(0,l.kt)("td",{parentName:"tr",align:null},"bytearray")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"strict")),(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Whether to enforce types strictly.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"context")),(0,l.kt)("td",{parentName:"tr",align:null},"dict","[str, Any]"),(0,l.kt)("td",{parentName:"tr",align:null},"None"),(0,l.kt)("td",{parentName:"tr",align:null},"Extra variables to pass to the validator.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returns"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Model")),(0,l.kt)("td",{parentName:"tr",align:null},"The validated Pydantic model.")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exceptions"),":"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"ValueError")),(0,l.kt)("td",{parentName:"tr",align:null},"If ",(0,l.kt)("inlineCode",{parentName:"td"},"json_data")," is not a JSON string.")))))}s.isMDXComponent=!0}}]);