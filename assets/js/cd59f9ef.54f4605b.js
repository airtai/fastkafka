"use strict";(self.webpackChunkfastkafka=self.webpackChunkfastkafka||[]).push([[1753],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=d(n),u=i,k=m["".concat(s,".").concat(u)]||m[u]||c[u]||o;return n?a.createElement(k,l(l({ref:t},p),{},{components:n})):a.createElement(k,l({ref:t},p))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[m]="string"==typeof e?e:i,l[1]=r;for(var d=2;d<o;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7411:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={},l=void 0,r={unversionedId:"api/fastkafka/testing/Tester",id:"version-0.6.0/api/fastkafka/testing/Tester",title:"Tester",description:"fastkafka.testing.Tester {fastkafka.testing.Tester}",source:"@site/versioned_docs/version-0.6.0/api/fastkafka/testing/Tester.md",sourceDirName:"api/fastkafka/testing",slug:"/api/fastkafka/testing/Tester",permalink:"/docs/0.6.0/api/fastkafka/testing/Tester",draft:!1,tags:[],version:"0.6.0",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"LocalRedpandaBroker",permalink:"/docs/0.6.0/api/fastkafka/testing/LocalRedpandaBroker"},next:{title:"fastkafka",permalink:"/docs/0.6.0/cli/fastkafka"}},s={},d=[{value:"<code>fastkafka.testing.Tester</code>",id:"fastkafka.testing.Tester",level:2},{value:"<code>__init__</code>",id:"init",level:3},{value:"<code>benchmark</code>",id:"benchmark",level:3},{value:"<code>consumes</code>",id:"consumes",level:3},{value:"<code>create_mocks</code>",id:"create_mocks",level:3},{value:"<code>produces</code>",id:"produces",level:3},{value:"<code>run_in_background</code>",id:"run_in_background",level:3},{value:"<code>using_local_kafka</code>",id:"using_local_kafka",level:3},{value:"<code>using_local_redpanda</code>",id:"using_local_redpanda",level:3}],p={toc:d},m="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"fastkafka.testing.Tester"},(0,i.kt)("inlineCode",{parentName:"h2"},"fastkafka.testing.Tester")),(0,i.kt)("h3",{id:"init"},(0,i.kt)("inlineCode",{parentName:"h3"},"__init__")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def __init__(self, app: Union[fastkafka.FastKafka, List[fastkafka.FastKafka]], broker: Optional[fastkafka.testing.ApacheKafkaBroker, fastkafka.testing.LocalRedpandaBroker, fastkafka._testing.in_memory_broker.InMemoryBroker] = None, topics: Iterable[str] = [], retries: int = 3, apply_nest_asyncio: bool = False, zookeeper_port: int = 2181, listener_port: int = 9092) -> None")),(0,i.kt)("p",null,"Mirror-like object for testing a FastKafka application"),(0,i.kt)("p",null,"Can be used as context manager"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data_dir"),": Path to the directory where the zookeepeer instance will save data"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zookeeper_port"),": Port for clients (Kafka brokes) to connect"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"listener_port"),": Port on which the clients (producers and consumers) can connect")),(0,i.kt)("h3",{id:"benchmark"},(0,i.kt)("inlineCode",{parentName:"h3"},"benchmark")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def benchmark(self: fastkafka.FastKafka, interval: Union[int, datetime.timedelta] = 1, sliding_window_size: Optional[int] = None) -> typing.Callable[[typing.Callable[[~I], typing.Optional[~O]]], typing.Callable[[~I], typing.Optional[~O]]]")),(0,i.kt)("p",null,"Decorator to benchmark produces/consumes functions"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"interval"),": Period to use to calculate throughput. If value is of type int,\nthen it will be used as seconds. If value is of type timedelta,\nthen it will be used as it is. default: 1 - one second"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sliding_window_size"),": The size of the sliding window to use to calculate\naverage throughput. default: None - By default average throughput is\nnot calculated")),(0,i.kt)("h3",{id:"consumes"},(0,i.kt)("inlineCode",{parentName:"h3"},"consumes")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def consumes(self: fastkafka.FastKafka, topic: Optional[str] = None, decoder: Union[str, Callable[[bytes, pydantic.main.ModelMetaclass], Any]] = 'json', executor: Optional[str, fastkafka._components.task_streaming.StreamExecutor] = None, prefix: str = 'on_', loop=None, bootstrap_servers='localhost', client_id='aiokafka-0.8.0', group_id=None, key_deserializer=None, value_deserializer=None, fetch_max_wait_ms=500, fetch_max_bytes=52428800, fetch_min_bytes=1, max_partition_fetch_bytes=1048576, request_timeout_ms=40000, retry_backoff_ms=100, auto_offset_reset='latest', enable_auto_commit=True, auto_commit_interval_ms=5000, check_crcs=True, metadata_max_age_ms=300000, partition_assignment_strategy=(<class 'kafka.coordinator.assignors.roundrobin.RoundRobinPartitionAssignor'>,), max_poll_interval_ms=300000, rebalance_timeout_ms=None, session_timeout_ms=10000, heartbeat_interval_ms=3000, consumer_timeout_ms=200, max_poll_records=None, ssl_context=None, security_protocol='PLAINTEXT', api_version='auto', exclude_internal_topics=True, connections_max_idle_ms=540000, isolation_level='read_uncommitted', sasl_mechanism='PLAIN', sasl_plain_password=None, sasl_plain_username=None, sasl_kerberos_service_name='kafka', sasl_kerberos_domain_name=None, sasl_oauth_token_provider=None) -> typing.Callable[[typing.Union[typing.Callable[[pydantic.main.BaseModel], typing.Awaitable[NoneType]], typing.Callable[[pydantic.main.BaseModel, fastkafka.EventMetadata], typing.Awaitable[NoneType]], typing.Callable[[pydantic.main.BaseModel], NoneType], typing.Callable[[pydantic.main.BaseModel, fastkafka.EventMetadata], NoneType]]], typing.Union[typing.Callable[[pydantic.main.BaseModel], typing.Awaitable[NoneType]], typing.Callable[[pydantic.main.BaseModel, fastkafka.EventMetadata], typing.Awaitable[NoneType]], typing.Callable[[pydantic.main.BaseModel], NoneType], typing.Callable[[pydantic.main.BaseModel, fastkafka.EventMetadata], NoneType]]]")),(0,i.kt)("p",null,"Decorator registering the callback called when a message is received in a topic."),(0,i.kt)("p",null,"This function decorator is also responsible for registering topics for AsyncAPI specificiation and documentation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"topic"),": Kafka topic that the consumer will subscribe to and execute the\ndecorated function when it receives a message from the topic,\ndefault: None. If the topic is not specified, topic name will be\ninferred from the decorated function name by stripping the defined prefix"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"decoder"),": Decoder to use to decode messages consumed from the topic,\ndefault: json - By default, it uses json decoder to decode\nbytes to json string and then it creates instance of pydantic\nBaseModel. It also accepts custom decoder function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"executor"),': Type of executor to choose for consuming tasks. Avaliable options\nare "SequentialExecutor" and "DynamicTaskExecutor". The default option is\n"SequentialExecutor" which will execute the consuming tasks sequentially.\nIf the consuming tasks have high latency it is recommended to use\n"DynamicTaskExecutor" which will wrap the consuming functions into tasks\nand run them in on asyncio loop in background. This comes with a cost of\nincreased overhead so use it only in cases when your consume functions have\nhigh latency such as database queries or some other type of networking.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prefix"),': Prefix stripped from the decorated function to define a topic name\nif the topic argument is not passed, default: "on_". If the decorated\nfunction name is not prefixed with the defined prefix and topic argument\nis not passed, then this method will throw ValueError'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"*topics"),": optional list of topics to subscribe to. If not set,\ncall :meth:",(0,i.kt)("inlineCode",{parentName:"li"},".subscribe")," or :meth:",(0,i.kt)("inlineCode",{parentName:"li"},".assign")," before consuming records.\nPassing topics directly is same as calling :meth:",(0,i.kt)("inlineCode",{parentName:"li"},".subscribe")," API."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bootstrap_servers"),": a ",(0,i.kt)("inlineCode",{parentName:"li"},"host[:port]")," string (or list of\n",(0,i.kt)("inlineCode",{parentName:"li"},"host[:port]")," strings) that the consumer should contact to bootstrap\ninitial cluster metadata.")),(0,i.kt)("p",null,"This does not have to be the full node list.\nIt just needs to have at least one broker that will respond to a\nMetadata API Request. Default port is 9092. If no servers are\nspecified, will default to ",(0,i.kt)("inlineCode",{parentName:"p"},"localhost:9092"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"client_id"),": a name for this client. This string is passed in\neach request to servers and can be used to identify specific\nserver-side log entries that correspond to this client. Also\nsubmitted to :class:",(0,i.kt)("inlineCode",{parentName:"li"},"~.consumer.group_coordinator.GroupCoordinator"),"\nfor logging with respect to consumer group administration. Default:\n",(0,i.kt)("inlineCode",{parentName:"li"},"aiokafka-{version}")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"group_id"),": name of the consumer group to join for dynamic\npartition assignment (if enabled), and to use for fetching and\ncommitting offsets. If None, auto-partition assignment (via\ngroup coordinator) and offset commits are disabled.\nDefault: None"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key_deserializer"),": Any callable that takes a\nraw message key and returns a deserialized key."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value_deserializer"),": Any callable that takes a\nraw message value and returns a deserialized value."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fetch_min_bytes"),": Minimum amount of data the server should\nreturn for a fetch request, otherwise wait up to\n",(0,i.kt)("inlineCode",{parentName:"li"},"fetch_max_wait_ms")," for more data to accumulate. Default: 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fetch_max_bytes"),": The maximum amount of data the server should\nreturn for a fetch request. This is not an absolute maximum, if\nthe first message in the first non-empty partition of the fetch\nis larger than this value, the message will still be returned\nto ensure that the consumer can make progress. NOTE: consumer\nperforms fetches to multiple brokers in parallel so memory\nusage will depend on the number of brokers containing\npartitions for the topic.\nSupported Kafka version >= 0.10.1.0. Default: 52428800 (50 Mb)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fetch_max_wait_ms"),": The maximum amount of time in milliseconds\nthe server will block before answering the fetch request if\nthere isn't sufficient data to immediately satisfy the\nrequirement given by fetch_min_bytes. Default: 500."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_partition_fetch_bytes"),": The maximum amount of data\nper-partition the server will return. The maximum total memory\nused for a request ",(0,i.kt)("inlineCode",{parentName:"li"},"= #partitions * max_partition_fetch_bytes"),".\nThis size must be at least as large as the maximum message size\nthe server allows or else it is possible for the producer to\nsend messages larger than the consumer can fetch. If that\nhappens, the consumer can get stuck trying to fetch a large\nmessage on a certain partition. Default: 1048576."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_poll_records"),": The maximum number of records returned in a\nsingle call to :meth:",(0,i.kt)("inlineCode",{parentName:"li"},".getmany"),". Defaults ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", no limit."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"request_timeout_ms"),": Client request timeout in milliseconds.\nDefault: 40000."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retry_backoff_ms"),": Milliseconds to backoff when retrying on\nerrors. Default: 100."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"auto_offset_reset"),": A policy for resetting offsets on\n:exc:",(0,i.kt)("inlineCode",{parentName:"li"},".OffsetOutOfRangeError")," errors: ",(0,i.kt)("inlineCode",{parentName:"li"},"earliest")," will move to the oldest\navailable message, ",(0,i.kt)("inlineCode",{parentName:"li"},"latest")," will move to the most recent, and\n",(0,i.kt)("inlineCode",{parentName:"li"},"none")," will raise an exception so you can handle this case.\nDefault: ",(0,i.kt)("inlineCode",{parentName:"li"},"latest"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"enable_auto_commit"),": If true the consumer's offset will be\nperiodically committed in the background. Default: True."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"auto_commit_interval_ms"),": milliseconds between automatic\noffset commits, if enable_auto_commit is True. Default: 5000."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"check_crcs"),": Automatically check the CRC32 of the records\nconsumed. This ensures no on-the-wire or on-disk corruption to\nthe messages occurred. This check adds some overhead, so it may\nbe disabled in cases seeking extreme performance. Default: True"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"metadata_max_age_ms"),": The period of time in milliseconds after\nwhich we force a refresh of metadata even if we haven't seen any\npartition leadership changes to proactively discover any new\nbrokers or partitions. Default: 300000"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"partition_assignment_strategy"),": List of objects to use to\ndistribute partition ownership amongst consumer instances when\ngroup management is used. This preference is implicit in the order\nof the strategies in the list. When assignment strategy changes:\nto support a change to the assignment strategy, new versions must\nenable support both for the old assignment strategy and the new\none. The coordinator will choose the old assignment strategy until\nall members have been updated. Then it will choose the new\nstrategy. Default: ","[:class:",(0,i.kt)("inlineCode",{parentName:"li"},".RoundRobinPartitionAssignor"),"]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_poll_interval_ms"),": Maximum allowed time between calls to\nconsume messages (e.g., :meth:",(0,i.kt)("inlineCode",{parentName:"li"},".getmany"),"). If this interval\nis exceeded the consumer is considered failed and the group will\nrebalance in order to reassign the partitions to another consumer\ngroup member. If API methods block waiting for messages, that time\ndoes not count against this timeout. See ",(0,i.kt)("inlineCode",{parentName:"li"},"KIP-62"),"_ for more\ninformation. Default 300000"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rebalance_timeout_ms"),": The maximum time server will wait for this\nconsumer to rejoin the group in a case of rebalance. In Java client\nthis behaviour is bound to ",(0,i.kt)("inlineCode",{parentName:"li"},"max.poll.interval.ms")," configuration,\nbut as ",(0,i.kt)("inlineCode",{parentName:"li"},"aiokafka")," will rejoin the group in the background, we\ndecouple this setting to allow finer tuning by users that use\n:class:",(0,i.kt)("inlineCode",{parentName:"li"},".ConsumerRebalanceListener")," to delay rebalacing. Defaults\nto ",(0,i.kt)("inlineCode",{parentName:"li"},"session_timeout_ms")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"session_timeout_ms"),": Client group session and failure detection\ntimeout. The consumer sends periodic heartbeats\n(",(0,i.kt)("inlineCode",{parentName:"li"},"heartbeat.interval.ms"),") to indicate its liveness to the broker.\nIf no hearts are received by the broker for a group member within\nthe session timeout, the broker will remove the consumer from the\ngroup and trigger a rebalance. The allowed range is configured with\nthe ",(0,i.kt)("strong",{parentName:"li"},"broker")," configuration properties\n",(0,i.kt)("inlineCode",{parentName:"li"},"group.min.session.timeout.ms")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"group.max.session.timeout.ms"),".\nDefault: 10000"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"heartbeat_interval_ms"),": The expected time in milliseconds\nbetween heartbeats to the consumer coordinator when using\nKafka's group management feature. Heartbeats are used to ensure\nthat the consumer's session stays active and to facilitate\nrebalancing when new consumers join or leave the group. The\nvalue must be set lower than ",(0,i.kt)("inlineCode",{parentName:"li"},"session_timeout_ms"),", but typically\nshould be set no higher than 1/3 of that value. It can be\nadjusted even lower to control the expected time for normal\nrebalances. Default: 3000"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"consumer_timeout_ms"),": maximum wait timeout for background fetching\nroutine. Mostly defines how fast the system will see rebalance and\nrequest new data for new partitions. Default: 200"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"api_version"),": specify which kafka API version to use.\n:class:",(0,i.kt)("inlineCode",{parentName:"li"},"AIOKafkaConsumer")," supports Kafka API versions >=0.9 only.\nIf set to ",(0,i.kt)("inlineCode",{parentName:"li"},"auto"),", will attempt to infer the broker version by\nprobing various APIs. Default: ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"security_protocol"),": Protocol used to communicate with brokers.\nValid values are: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAINTEXT"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SSL"),". Default: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAINTEXT"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ssl_context"),": pre-configured :class:",(0,i.kt)("inlineCode",{parentName:"li"},"~ssl.SSLContext"),"\nfor wrapping socket connections. Directly passed into asyncio's\n:meth:",(0,i.kt)("inlineCode",{parentName:"li"},"~asyncio.loop.create_connection"),". For more information see\n:ref:",(0,i.kt)("inlineCode",{parentName:"li"},"ssl_auth"),". Default: None."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"exclude_internal_topics"),": Whether records from internal topics\n(such as offsets) should be exposed to the consumer. If set to True\nthe only way to receive records from an internal topic is\nsubscribing to it. Requires 0.10+ Default: True"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connections_max_idle_ms"),": Close idle connections after the number\nof milliseconds specified by this config. Specifying ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," will\ndisable idle checks. Default: 540000 (9 minutes)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isolation_level"),": Controls how to read messages written\ntransactionally.")),(0,i.kt)("p",null,"If set to ",(0,i.kt)("inlineCode",{parentName:"p"},"read_committed"),", :meth:",(0,i.kt)("inlineCode",{parentName:"p"},".getmany")," will only return\ntransactional messages which have been committed.\nIf set to ",(0,i.kt)("inlineCode",{parentName:"p"},"read_uncommitted")," (the default), :meth:",(0,i.kt)("inlineCode",{parentName:"p"},".getmany")," will\nreturn all messages, even transactional messages which have been\naborted."),(0,i.kt)("p",null,"Non-transactional messages will be returned unconditionally in\neither mode."),(0,i.kt)("p",null,"Messages will always be returned in offset order. Hence, in\n",(0,i.kt)("inlineCode",{parentName:"p"},"read_committed")," mode, :meth:",(0,i.kt)("inlineCode",{parentName:"p"},".getmany")," will only return\nmessages up to the last stable offset (LSO), which is the one less\nthan the offset of the first open transaction. In particular any\nmessages appearing after messages belonging to ongoing transactions\nwill be withheld until the relevant transaction has been completed.\nAs a result, ",(0,i.kt)("inlineCode",{parentName:"p"},"read_committed")," consumers will not be able to read up\nto the high watermark when there are in flight transactions.\nFurther, when in ",(0,i.kt)("inlineCode",{parentName:"p"},"read_committed")," the seek_to_end method will\nreturn the LSO. See method docs below. Default: ",(0,i.kt)("inlineCode",{parentName:"p"},"read_uncommitted")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_mechanism"),": Authentication mechanism when security_protocol\nis configured for ",(0,i.kt)("inlineCode",{parentName:"li"},"SASL_PLAINTEXT")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"SASL_SSL"),". Valid values are:\n",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"GSSAPI"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SCRAM-SHA-256"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SCRAM-SHA-512"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"OAUTHBEARER"),".\nDefault: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_plain_username"),": username for SASL ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN")," authentication.\nDefault: None"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_plain_password"),": password for SASL ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN")," authentication.\nDefault: None"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_oauth_token_provider"),": OAuthBearer token provider instance. (See :mod:",(0,i.kt)("inlineCode",{parentName:"li"},"kafka.oauth.abstract"),").\nDefault: None")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},": A function returning the same function")),(0,i.kt)("h3",{id:"create_mocks"},(0,i.kt)("inlineCode",{parentName:"h3"},"create_mocks")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def create_mocks(self: fastkafka.FastKafka) -> None")),(0,i.kt)("p",null,"Creates self.mocks as a named tuple mapping a new function obtained by calling the original functions and a mock"),(0,i.kt)("h3",{id:"produces"},(0,i.kt)("inlineCode",{parentName:"h3"},"produces")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def produces(self: fastkafka.FastKafka, topic: Optional[str] = None, encoder: Union[str, Callable[[pydantic.main.BaseModel], bytes]] = 'json', prefix: str = 'to_', loop=None, bootstrap_servers='localhost', client_id=None, metadata_max_age_ms=300000, request_timeout_ms=40000, api_version='auto', acks=<object object at 0x7fa3e2864f70>, key_serializer=None, value_serializer=None, compression_type=None, max_batch_size=16384, partitioner=<kafka.partitioner.default.DefaultPartitioner object at 0x7fa3e1879090>, max_request_size=1048576, linger_ms=0, send_backoff_ms=100, retry_backoff_ms=100, security_protocol='PLAINTEXT', ssl_context=None, connections_max_idle_ms=540000, enable_idempotence=False, transactional_id=None, transaction_timeout_ms=60000, sasl_mechanism='PLAIN', sasl_plain_password=None, sasl_plain_username=None, sasl_kerberos_service_name='kafka', sasl_kerberos_domain_name=None, sasl_oauth_token_provider=None) -> typing.Callable[[typing.Union[typing.Callable[..., typing.Union[pydantic.main.BaseModel, fastkafka.KafkaEvent[pydantic.main.BaseModel], typing.List[pydantic.main.BaseModel], fastkafka.KafkaEvent[typing.List[pydantic.main.BaseModel]]]], typing.Callable[..., typing.Awaitable[typing.Union[pydantic.main.BaseModel, fastkafka.KafkaEvent[pydantic.main.BaseModel], typing.List[pydantic.main.BaseModel], fastkafka.KafkaEvent[typing.List[pydantic.main.BaseModel]]]]]]], typing.Union[typing.Callable[..., typing.Union[pydantic.main.BaseModel, fastkafka.KafkaEvent[pydantic.main.BaseModel], typing.List[pydantic.main.BaseModel], fastkafka.KafkaEvent[typing.List[pydantic.main.BaseModel]]]], typing.Callable[..., typing.Awaitable[typing.Union[pydantic.main.BaseModel, fastkafka.KafkaEvent[pydantic.main.BaseModel], typing.List[pydantic.main.BaseModel], fastkafka.KafkaEvent[typing.List[pydantic.main.BaseModel]]]]]]]")),(0,i.kt)("p",null,"Decorator registering the callback called when delivery report for a produced message is received"),(0,i.kt)("p",null,"This function decorator is also responsible for registering topics for AsyncAPI specificiation and documentation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"topic"),": Kafka topic that the producer will send returned values from\nthe decorated function to, default: None- If the topic is not\nspecified, topic name will be inferred from the decorated function\nname by stripping the defined prefix."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"encoder"),": Encoder to use to encode messages before sending it to topic,\ndefault: json - By default, it uses json encoder to convert\npydantic basemodel to json string and then encodes the string to bytes\nusing 'utf-8' encoding. It also accepts custom encoder function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prefix"),': Prefix stripped from the decorated function to define a topic\nname if the topic argument is not passed, default: "to_". If the\ndecorated function name is not prefixed with the defined prefix\nand topic argument is not passed, then this method will throw ValueError'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bootstrap_servers"),": a ",(0,i.kt)("inlineCode",{parentName:"li"},"host[:port]")," string or list of\n",(0,i.kt)("inlineCode",{parentName:"li"},"host[:port]")," strings that the producer should contact to\nbootstrap initial cluster metadata. This does not have to be the\nfull node list.  It just needs to have at least one broker that will\nrespond to a Metadata API Request. Default port is 9092. If no\nservers are specified, will default to ",(0,i.kt)("inlineCode",{parentName:"li"},"localhost:9092"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"client_id"),": a name for this client. This string is passed in\neach request to servers and can be used to identify specific\nserver-side log entries that correspond to this client.\nDefault: ",(0,i.kt)("inlineCode",{parentName:"li"},"aiokafka-producer-#")," (appended with a unique number\nper instance)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key_serializer"),": used to convert user-supplied keys to bytes\nIf not :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", called as ",(0,i.kt)("inlineCode",{parentName:"li"},"f(key),")," should return\n:class:",(0,i.kt)("inlineCode",{parentName:"li"},"bytes"),".\nDefault: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value_serializer"),": used to convert user-supplied message\nvalues to :class:",(0,i.kt)("inlineCode",{parentName:"li"},"bytes"),". If not :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", called as\n",(0,i.kt)("inlineCode",{parentName:"li"},"f(value)"),", should return :class:",(0,i.kt)("inlineCode",{parentName:"li"},"bytes"),".\nDefault: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"acks"),": one of ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"all"),". The number of acknowledgments\nthe producer requires the leader to have received before considering a\nrequest complete. This controls the durability of records that are\nsent. The following settings are common:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0"),": Producer will not wait for any acknowledgment from the server\nat all. The message will immediately be added to the socket\nbuffer and considered sent. No guarantee can be made that the\nserver has received the record in this case, and the retries\nconfiguration will not take effect (as the client won't\ngenerally know of any failures). The offset given back for each\nrecord will always be set to -1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1"),": The broker leader will write the record to its local log but\nwill respond without awaiting full acknowledgement from all\nfollowers. In this case should the leader fail immediately\nafter acknowledging the record but before the followers have\nreplicated it then the record will be lost."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"all"),": The broker leader will wait for the full set of in-sync\nreplicas to acknowledge the record. This guarantees that the\nrecord will not be lost as long as at least one in-sync replica\nremains alive. This is the strongest available guarantee.")),(0,i.kt)("p",null,"If unset, defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"acks=1"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"enable_idempotence")," is\n:data:",(0,i.kt)("inlineCode",{parentName:"p"},"True")," defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"acks=all")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"compression_type"),": The compression type for all data generated by\nthe producer. Valid values are ",(0,i.kt)("inlineCode",{parentName:"li"},"gzip"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"snappy"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"lz4"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"zstd"),"\nor :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),".\nCompression is of full batches of data, so the efficacy of batching\nwill also impact the compression ratio (more batching means better\ncompression). Default: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_batch_size"),": Maximum size of buffered data per partition.\nAfter this amount :meth:",(0,i.kt)("inlineCode",{parentName:"li"},"send")," coroutine will block until batch is\ndrained.\nDefault: 16384"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"linger_ms"),": The producer groups together any records that arrive\nin between request transmissions into a single batched request.\nNormally this occurs only under load when records arrive faster\nthan they can be sent out. However in some circumstances the client\nmay want to reduce the number of requests even under moderate load.\nThis setting accomplishes this by adding a small amount of\nartificial delay; that is, if first request is processed faster,\nthan ",(0,i.kt)("inlineCode",{parentName:"li"},"linger_ms"),", producer will wait ",(0,i.kt)("inlineCode",{parentName:"li"},"linger_ms - process_time"),".\nDefault: 0 (i.e. no delay)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"partitioner"),": Callable used to determine which partition\neach message is assigned to. Called (after key serialization):\n",(0,i.kt)("inlineCode",{parentName:"li"},"partitioner(key_bytes, all_partitions, available_partitions)"),".\nThe default partitioner implementation hashes each non-None key\nusing the same murmur2 algorithm as the Java client so that\nmessages with the same key are assigned to the same partition.\nWhen a key is :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"),", the message is delivered to a random partition\n(filtered to partitions with available leaders only, if possible)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max_request_size"),": The maximum size of a request. This is also\neffectively a cap on the maximum record size. Note that the server\nhas its own cap on record size which may be different from this.\nThis setting will limit the number of record batches the producer\nwill send in a single request to avoid sending huge requests.\nDefault: 1048576."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"metadata_max_age_ms"),": The period of time in milliseconds after\nwhich we force a refresh of metadata even if we haven't seen any\npartition leadership changes to proactively discover any new\nbrokers or partitions. Default: 300000"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"request_timeout_ms"),": Produce request timeout in milliseconds.\nAs it's sent as part of\n:class:",(0,i.kt)("inlineCode",{parentName:"li"},"~kafka.protocol.produce.ProduceRequest")," (it's a blocking\ncall), maximum waiting time can be up to ",(0,i.kt)("inlineCode",{parentName:"li"},"2 *\nrequest_timeout_ms"),".\nDefault: 40000."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retry_backoff_ms"),": Milliseconds to backoff when retrying on\nerrors. Default: 100."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"api_version"),": specify which kafka API version to use.\nIf set to ",(0,i.kt)("inlineCode",{parentName:"li"},"auto"),", will attempt to infer the broker version by\nprobing various APIs. Default: ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"security_protocol"),": Protocol used to communicate with brokers.\nValid values are: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAINTEXT"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SSL"),". Default: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAINTEXT"),".\nDefault: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAINTEXT"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ssl_context"),": pre-configured :class:",(0,i.kt)("inlineCode",{parentName:"li"},"~ssl.SSLContext"),"\nfor wrapping socket connections. Directly passed into asyncio's\n:meth:",(0,i.kt)("inlineCode",{parentName:"li"},"~asyncio.loop.create_connection"),". For more\ninformation see :ref:",(0,i.kt)("inlineCode",{parentName:"li"},"ssl_auth"),".\nDefault: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connections_max_idle_ms"),": Close idle connections after the number\nof milliseconds specified by this config. Specifying :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None")," will\ndisable idle checks. Default: 540000 (9 minutes)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"enable_idempotence"),": When set to :data:",(0,i.kt)("inlineCode",{parentName:"li"},"True"),", the producer will\nensure that exactly one copy of each message is written in the\nstream. If :data:",(0,i.kt)("inlineCode",{parentName:"li"},"False"),", producer retries due to broker failures,\netc., may write duplicates of the retried message in the stream.\nNote that enabling idempotence acks to set to ",(0,i.kt)("inlineCode",{parentName:"li"},"all"),". If it is not\nexplicitly set by the user it will be chosen. If incompatible\nvalues are set, a :exc:",(0,i.kt)("inlineCode",{parentName:"li"},"ValueError")," will be thrown.\nNew in version 0.5.0."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_mechanism"),": Authentication mechanism when security_protocol\nis configured for ",(0,i.kt)("inlineCode",{parentName:"li"},"SASL_PLAINTEXT")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"SASL_SSL"),". Valid values\nare: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"GSSAPI"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SCRAM-SHA-256"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"SCRAM-SHA-512"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"OAUTHBEARER"),".\nDefault: ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_plain_username"),": username for SASL ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN")," authentication.\nDefault: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_plain_password"),": password for SASL ",(0,i.kt)("inlineCode",{parentName:"li"},"PLAIN")," authentication.\nDefault: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sasl_oauth_token_provider ("),": class:",(0,i.kt)("inlineCode",{parentName:"li"},"~aiokafka.abc.AbstractTokenProvider"),"):\nOAuthBearer token provider instance. (See\n:mod:",(0,i.kt)("inlineCode",{parentName:"li"},"kafka.oauth.abstract"),").\nDefault: :data:",(0,i.kt)("inlineCode",{parentName:"li"},"None"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},": A function returning the same function")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Exceptions"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ValueError"),": when needed")),(0,i.kt)("h3",{id:"run_in_background"},(0,i.kt)("inlineCode",{parentName:"h3"},"run_in_background")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def run_in_background(self: fastkafka.FastKafka) -> typing.Callable[[typing.Callable[..., typing.Coroutine[typing.Any, typing.Any, typing.Any]]], typing.Callable[..., typing.Coroutine[typing.Any, typing.Any, typing.Any]]]")),(0,i.kt)("p",null,"Decorator to schedule a task to be run in the background."),(0,i.kt)("p",null,"This decorator is used to schedule a task to be run in the background when the app's ",(0,i.kt)("inlineCode",{parentName:"p"},"_on_startup")," event is triggered."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A decorator function that takes a background task as an input and stores it to be run in the backround.")),(0,i.kt)("h3",{id:"using_local_kafka"},(0,i.kt)("inlineCode",{parentName:"h3"},"using_local_kafka")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def using_local_kafka(self, topics: Iterable[str] = [], retries: int = 3, apply_nest_asyncio: bool = False, zookeeper_port: int = 2181, listener_port: int = 9092) -> Tester")),(0,i.kt)("p",null,"Starts local Kafka broker used by the Tester instance"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data_dir"),": Path to the directory where the zookeepeer instance will save data"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zookeeper_port"),": Port for clients (Kafka brokes) to connect"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"listener_port"),": Port on which the clients (producers and consumers) can connect")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An instance of tester with Kafka as broker")),(0,i.kt)("h3",{id:"using_local_redpanda"},(0,i.kt)("inlineCode",{parentName:"h3"},"using_local_redpanda")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"def using_local_redpanda(self, topics: Iterable[str] = [], retries: int = 3, apply_nest_asyncio: bool = False, listener_port: int = 9092, tag: str = 'v23.1.2', seastar_core: int = 1, memory: str = '1G', mode: str = 'dev-container', default_log_level: str = 'debug') -> Tester")),(0,i.kt)("p",null,"Starts local Redpanda broker used by the Tester instance"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"listener_port"),": Port on which the clients (producers and consumers) can connect"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tag"),": Tag of Redpanda image to use to start container"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"seastar_core"),": Core(s) to use byt Seastar (the framework Redpanda uses under the hood)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"memory"),": The amount of memory to make available to Redpanda"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mode"),": Mode to use to load configuration properties in container"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default_log_level"),": Log levels to use for Redpanda")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An instance of tester with Redpanda as broker")))}c.isMDXComponent=!0}}]);